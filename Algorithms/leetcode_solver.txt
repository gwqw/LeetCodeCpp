common
1) проверка на INT_MAX
2) написать решение в псевдокоде и реализовать каждую функция псевдокода с помощью класса

array, string
паттерны: 
1) словарь: пройтись по массиву и создать словарь статистики, пройтись второй раз -- использовать словарь и решить задачу
2) 2 указателя, м.б. в одну сторону(печать), м.б. в разную. Например, нужно найти в отсортированном массиве элементы с опр. ограничением. Контейнер с наибольшим количеством воды. сумма триплета
3) binary search
4) поиск с запоминанием позиции и продолжением с этого места
5) dynamic programming: идём по массиву и получаем для данной ячейки наилучшую характеристику на основе вычисленных для предыдущих и зн. в текущей. Наиболее длинный палиндром. LIS
6) двойной проход: проход в прямом порядке и создание массива характеристик, проход в обратном порядком и создание массива других характеристик: задачи на разности
7) один проход, м.б. один проход по строке или параллельно по нескольким строкам
8) отсортировать(часто там же, где можно использовать словарь), обратить часть элементов
9) интегральная или префиксная сумма: is[i] = is[i-1] + n[i]
10) сложить все числа или xor: если есть 2 похожих массива или строки
11) bucket_sort/radix_sort, если известно что-то о числах в массиве
13) nth-element
14) priority queue
15) найти 2-3 минимальных/максимальных элемента за один проход
16) исполнение команд: печать символа, удалить символ.
17) stack: позволяет для каждого элемента помнить/получать характеристику, обычно помнить больший элемент
18) sliding window: для поиска какого-то подмассива (подстроки)
19) split in 3 intervals: идём по массиву, если cond1 -> swap в левой границей среднего интервала, иначе с правой и продвигаем их
20) search 3 mins: есть несколько минимумов. e.g. найти возрастающий триплет 
21) precalc sums: найти все 4 элемента, таких, что их сумма == target, precalc sums(x+y)
22) find all subarrays with target sum: prefix sum && set or map, заполнять set нужно по ходу в одном цикле.
примеры:
- удалить дубликаты: 2 итератора в одну сторону -- аналог печати
- объединение сортированных массивов: 2 итератора: сдвинуть на n-элементов и печатать в начало меньший
- палиндром: 2 итератора в обратном порядке

number/numbers:
паттерн: 
1) работа с цифрами: digit = num % 10, num /= 10
2) binary_search: например для получения квадратного корня
3) radix sort: для неупорядоченного массива последовательных чисел
4) использование формул: сумма всех чисел от 1 до n, посмотреть остатки от деления на 3, 9, ...
5) решето Эратосфена для простых чисел: 

LinkedList
паттерны:
1) иттеративный: стек, проход по списку
2) рекурсия
3) использование кеша
4) рассчитать и использовать длину, например для шифта
примеры:
- нахождение точки пересечения: получить длину, сдвинуться на разность и найти точку
- цикл: черепаха и заяц. когда встретились, один идёт от точки встречи, второй от начала, они встретятся в т. начала цикла (является ли связанный список палиндромом)

Tree
паттерны:
1) dfs наше всё
2) bfs
3) использование свойства bst
4) использование префиксных сумм
5) считать высоты и использовать их для принятия решений (например, для сравнения)
6) TreeIterator
7) use stack, when go through tree

Graphs
1) dfs/bfs
2) Топологическая сортировка: visited<bool>, ans.push_back() в конце dfs
3) поиск цикла: visited<bool> -> mark<3 states>

Long arithmetic
паттерны:
1) проход по числу(числам) и помним перенос

Bits
patterns:
1) использовать цифры как для десятичной системы: d = n & 1, n >>= 1
2) создание предрасчётных таблиц для частей
3) удалить последнюю 1: n &= n - 1
4) степень двойки: n & (n-1)
5) использование битовых масок
6) использование двоичного поиска

Матрицы
1) проход по матрице
2) path (вправо и вниз): dp or combinatoric
3) as graph

Комбинаторика
backtracking

Classic
- Правильный набор скобок: use stack
- МинСтек: 2 стека
- очередь из стеков: 2 стека
- Нахождение цикла в односвязном списке: 2 указателя с разной скоростью (один с двойной)
- rotate string: проверка substr в str+str
- генерация всех скобочных последовательностей: рекурсия

Design
- stack with inc k element: vector<pair<int>> {value, inc}
- LRU: dict[key]->list::iterator, list: key,value
- LFU: 2 dicts. Event{key, value, freq}. dict1[key]->list::iterator, d2[freq]->list<Event>
- Add and search word with pattern: trie
- Итератор вложенных списков: IteratorRange + stack<IteratorRange>
- HitCounter: sliding window: deque<event> data, Event {time, cnt}
- Insert, Delete, GetRandom: vector<int>, dict<int>->idx
- All O(1): inc(key), dec(key), getMaxKey, getMinKey(): list<Node>, dict[key]->list::iterator. Node{value, set<keys>}
